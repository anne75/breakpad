#include "md2core_aarch64.h"
#include "md2core.h"

namespace md2core {

  CrashedProcessAarch64::CrashedProcessAarch64() {
    crashing_tid = -1;
    auxv = NULL;
    auxv_length = 0;
    memset(&prps, 0, sizeof(prps));
    prps.pr_sname = 'R';
    memset(&debug, 0, sizeof(debug));
    elf_arch = EM_AARCH64;
  }


  void
  CrashedProcessAarch64::ParseThreadRegisters(Threadaarch64* thread,
					      const MinidumpMemoryRange& range) {
    const MDRawContextARM64* rawregs = range.GetData<MDRawContextARM64>(0);

    for (int i = 0; i < 31; ++i)
      thread->regs.regs[i] = rawregs->iregs[i];
    thread->regs.sp = rawregs->iregs[MD_CONTEXT_ARM64_REG_SP];
    thread->regs.pc = rawregs->iregs[MD_CONTEXT_ARM64_REG_PC];
    thread->regs.pstate = rawregs->cpsr;

    memcpy(thread->fpregs.vregs, rawregs->float_save.regs, 8 * 32);
    thread->fpregs.fpsr = rawregs->float_save.fpsr;
    thread->fpregs.fpcr = rawregs->float_save.fpcr;
  }


  void
  CrashedProcessAarch64::ParseSystemInfo(const Options& options,
					 const MinidumpMemoryRange& range,
					 const MinidumpMemoryRange& full_file) {
    const MDRawSystemInfo* sysinfo = range.GetData<MDRawSystemInfo>(0);
    if (!sysinfo) {
      fprintf(stderr, "Failed to access MD_SYSTEM_INFO_STREAM\n");
      exit(1);
  }
    if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_ARM64) {
      fprintf(stderr,
	      "This version of minidump-2-core only supports ARM (64bit).\n");
      exit(1);
    }
    if (!strstr(full_file.GetAsciiMDString(sysinfo->csd_version_rva).c_str(),
		"Linux") &&
	sysinfo->platform_id != MD_OS_NACL) {
      fprintf(stderr, "This minidump was not generated by Linux or NaCl.\n");
      exit(1);
    }
// call super
    CrashedProcess<Threadaarch64, prpsinfoaarch64,
		   prstatusaarch64, user_fpsimd_struct,
		   user_regsaarch64_struct>::ParseSystemInfo(options, range, full_file);
  }

  
  void CrashedProcessAarch64::write_threads(const Options& options) {
    for (unsigned i = 0; i < threads.size(); ++i) {
      if (threads[i].tid != crashing_tid)
	WriteThread(options, threads[i], fatal_signal);
    }
  }
  

}
